

                                    F           L-0
                                 /    \          
                                D      J        L-1
                                /\     /\
                               B  E   G  K      L-2
                               /\      \    
                              A  C      I       L-3
                                       /
                                      H         L-4


DFS -> F,D,B,A,C,E,J,G,I,H,K
here we will go to a child and we would complete the whole subtree of that child before going to the next child.
we can visit left subtree, right sibtree or root in different order.
there are three popular depth first strategies.

<root><left><right> = preorder (DLR)
1. visit root
2. visit left subtree
3. visit right subtree

F,D,B,A,C,E,J,G,I,H,K

<left><root><right> = inorder  (LDR) 
we will first finish visiting the left subtree then current node and then go right.
A,B,C,D,E,F,G,H,I,J,K

(its bascailly get a sorted list)

<left><right><root> = postorder (LRD)
A,C,B,E,D,H,I,G,K,J,F

time complexity is O(n)
space complexity is O(h)
worst case o(n)
best/avg: O(logn)


#include<iostream>
using namespace std;
 
struct Node {
	char data;
	struct Node *left;
	struct Node *right;
};

//Function to visit nodes in Preorder
void Preorder(struct Node *root) {
	// base condition for recursion
	// if tree/sub-tree is empty, return and exit
	if(root == NULL) return;

	printf("%c ",root->data); // Print data
	Preorder(root->left);     // Visit left subtree
	Preorder(root->right);    // Visit right subtree
}

//Function to visit nodes in Inorder
void Inorder(Node *root) {
	if(root == NULL) return;

	Inorder(root->left);       //Visit left subtree
	printf("%c ",root->data);  //Print data
	Inorder(root->right);      // Visit right subtree
}

//Function to visit nodes in Postorder
void Postorder(Node *root) {
	if(root == NULL) return;

	Postorder(root->left);    // Visit left subtree
	Postorder(root->right);   // Visit right subtree
	printf("%c ",root->data); // Print data
}

// Function to Insert Node in a Binary Search Tree
Node* Insert(Node *root,char data) {
	if(root == NULL) {
		root = new Node();
		root->data = data;
		root->left = root->right = NULL;
	}
	else if(data <= root->data)
		root->left = Insert(root->left,data);
	else 
		root->right = Insert(root->right,data);
	return root;
}
 
int main() {
	/*Code To Test the logic
	  Creating an example tree
	                    M
			   / \
			  B   Q
			 / \   \
			A   C   Z
    */
	Node* root = NULL;
	root = Insert(root,'M'); root = Insert(root,'B');
	root = Insert(root,'Q'); root = Insert(root,'Z'); 
	root = Insert(root,'A'); root = Insert(root,'C');
	//Print Nodes in Preorder. 
	cout<<"Preorder: ";
	Preorder(root);
	cout<<"\n";
	//Print Nodes in Inorder
	cout<<"Inorder: ";
	Inorder(root);
	cout<<"\n";
	//Print Nodes in Postorder
	cout<<"Postorder: ";
	Postorder(root);
	cout<<"\n";
}


link: https://gist.github.com/mycodeschool/10016271
